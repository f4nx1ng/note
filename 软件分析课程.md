### Introduce

在这节课当中主要讲述了关于静态分析的总览内容，从一种比较宏观的角度来看待静态分析的一些概念。

###### sound，complete

首先，比较重要的概念就是sound，complete，这两个概念是关于静态分析的覆盖性问题。通过下面这张图我们可以简单的理解该问题的一些内容。我们不难发现sound事实上就是全面、包含所有缺陷但是却有误报的情况，而complete是不够全面但是小而精的一种分析方式会形成漏报。

![1](E:\JAVA安全\其他\静态代码分析\note\image\1.jpg)

对于这两个情况而言，当前所有的静态分析都追求sound而不是complete，其实这也很好理解，因为sound即便有误报也可以通过后期的验证进行排除处理。而complete是真的没有检测出来已有漏洞，后续如何检测也于事无补。但是sound的静态分析也有区别，有些sound针对各个条目比较精准，但是有些不够精准，精准的分析时间消耗过大，不精准的效率奇高。那如何平衡这两点是做好一个优秀sound静态分析的关键所在。

![2](E:\JAVA安全\其他\静态代码分析\note\image\2.png)

###### Abstraction，Over-approximation

静态分析分为两个主要的步骤：抽象和近似(拟合)

![3](E:\JAVA安全\其他\静态代码分析\note\image\3.png)

抽象的意思是我们要把想要去解决的目标(problem)，进行抽象，比如我们想要划分程序当中的正负值，我们就可以通过下面的抽象形式

![4](E:\JAVA安全\其他\静态代码分析\note\image\4.png)

我们已经将所有的情况都考虑清楚了，但是在程序运行的过程中不止有直接赋值的情况还有表达式计算，对于这些情况我们可以使用近似的第一种方式（Transfer Function），如下图所示，我们将各种情况的trnasfer function都定义出来，然后根据程序当中出现的情况依次对应入座。

![5](E:\JAVA安全\其他\静态代码分析\note\image\5.png)

第二种近似方式（control flow），我们可以通过Transfer Function的形式实现了针对表达式赋值情况正负号判断，但是在有些情况表达式之间的赋值也是值得注意的一点，比如某一个变量的正负是由前一个表达式来决定的，那么这个时候就需要使用控制流图

![6](E:\JAVA安全\其他\静态代码分析\note\image\6.png)

在汇聚点进行merge操作，也就意味需要在汇聚点应用transfer function